/**
 * MCDU Driver - Dual-backend (Mac: node-hid, Linux: usb control transfers)
 *
 * Root cause discovery: WinWing firmware requires SET_REPORT control transfers.
 * - Mac IOHIDManager uses IOHIDDeviceSetReport() = control transfers (works)
 * - Linux hidraw/libusb uses interrupt OUT transfers (firmware ignores them)
 *
 * Fix: on Linux, use the `usb` npm package to send control transfers directly.
 */

const PAGE_LINES = 14;
const PAGE_CHARS_PER_LINE = 24;

const VENDOR_ID = 0x4098;
const PRODUCT_ID = 0xbb36;

const COLORS = {
    'L': 0x0000,
    'A': 0x0021,
    'W': 0x0042,
    'B': 0x0063,
    'G': 0x0084,
    'M': 0x00A5,
    'R': 0x00C6,
    'Y': 0x00E7,
    'E': 0x0108,
};

const LEDS = {
    BACKLIGHT: 0,
    SCREEN_BACKLIGHT: 1,
    FAIL: 8,
    FM: 9,
    MCDU: 10,
    MENU: 11,
    FM1: 12,
    IND: 13,
    RDY: 14,
    STATUS: 15,
    FM2: 16,
};

const INIT_PACKETS = [
    [0xf0, 0x0, 0x1, 0x38, 0x32, 0xbb, 0x0, 0x0, 0x1e, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x18, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x34, 0x0, 0x18, 0x0, 0xe, 0x0, 0x18, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x2, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x5, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x1, 0x0, 0x6, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x3, 0x38, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0xff, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x4, 0x38, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0xff, 0xff, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0x0, 0xff, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x5, 0x38, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0x63, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x6, 0x38, 0xff, 0xff, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x7, 0x38, 0x0, 0x0, 0x2, 0x0, 0x0, 0xff, 0xff, 0xff, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x42, 0x5c, 0x61, 0xff, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x8, 0x38, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x77, 0x77, 0x77, 0xff, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5e, 0x73, 0x79, 0xff, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x9, 0x38, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x20, 0x20, 0x20, 0xff, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xa, 0x38, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0xff, 0xff, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xb, 0x38, 0xff, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xc, 0x38, 0x0, 0x3, 0x0, 0xff, 0x63, 0xff, 0xff, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0xff, 0xff, 0x15, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xd, 0x38, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xff, 0xff, 0xff, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x42, 0x5c, 0x61, 0xff, 0x17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xe, 0x38, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x77, 0x77, 0x77, 0xff, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x5e, 0x73, 0x79, 0xff, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xf, 0x38, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x10, 0x38, 0x1b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x1a, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x11, 0x12, 0x2, 0x32, 0xbb, 0x0, 0x0, 0x1c, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
];

class MCDU {
    constructor() {
        this._platform = process.platform;
        // Mac backend (node-hid)
        this._hidDevice = null;
        this._buttonPollInterval = null;
        // Linux backend (usb package, control transfers)
        this._usbDevice = null;
        this._usbIface = null;
        this._inEndpoint = null;
        // Shared state
        this.buttonCallback = null;
        this.page = this._createEmptyPage();
        this.colors = this._createEmptyColorBuffer();
    }

    _createEmptyColorBuffer() {
        const buf = [];
        for (let i = 0; i < PAGE_LINES; i++) buf.push(Array(PAGE_CHARS_PER_LINE).fill('W'));
        return buf;
    }

    _createEmptyPage() {
        const page = [];
        for (let i = 0; i < PAGE_LINES; i++) page.push(' '.repeat(PAGE_CHARS_PER_LINE));
        return page;
    }

    // -------------------------------------------------------------------------
    // Connection
    // -------------------------------------------------------------------------

    connect() {
        if (this._platform === 'linux') {
            return this._connectLinux();
        } else {
            return this._connectMac();
        }
    }

    _connectMac() {
        try {
            const HID = require('node-hid');
            this._hidDevice = new HID.HID(VENDOR_ID, PRODUCT_ID);
            console.log('✓ Connected (Mac/node-hid)');
            return true;
        } catch (err) {
            console.error('✗ Connect failed:', err.message);
            return false;
        }
    }

    _connectLinux() {
        try {
            const usb = require('usb');
            this._usbDevice = usb.findByIds(VENDOR_ID, PRODUCT_ID);
            if (!this._usbDevice) throw new Error('Device not found');

            this._usbDevice.open();
            this._usbIface = this._usbDevice.interface(0);

            if (this._usbIface.isKernelDriverActive()) {
                this._usbIface.detachKernelDriver();
            }
            this._usbIface.claim();

            // Interrupt IN endpoint for button reads
            this._inEndpoint = this._usbIface.endpoint(0x81);

            console.log('✓ Connected (Linux/usb control-transfer)');
            return true;
        } catch (err) {
            console.error('✗ Connect failed:', err.message);
            return false;
        }
    }

    // -------------------------------------------------------------------------
    // Low-level write: SET_REPORT control transfer (Linux) or node-hid (Mac)
    // -------------------------------------------------------------------------

    /**
     * Write one HID output packet.
     * packet[0] = report ID, packet[1..] = payload (total 64 bytes)
     * Returns a Promise on Linux, undefined on Mac (sync).
     */
    _write(packet) {
        if (this._platform === 'linux') {
            if (!this._usbDevice) return Promise.resolve();
            return this._ctrlTransfer(packet);
        } else {
            if (!this._hidDevice) return;
            this._hidDevice.write(Buffer.from(packet));
        }
    }

    _ctrlTransfer(packet) {
        return new Promise((resolve, reject) => {
            const reportId = packet[0];
            const data = Buffer.from(packet.slice(1)); // 63 bytes, no report ID
            // wValue = (Output=0x02 << 8) | reportId — mirrors IOHIDDeviceSetReport
            const wValue = (0x02 << 8) | reportId;
            this._usbDevice.controlTransfer(
                0x21,    // bmRequestType: Host→Device, Class, Interface
                0x09,    // bRequest: SET_REPORT
                wValue,  // wValue
                0,       // wIndex: interface 0
                data,
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
    }

    // -------------------------------------------------------------------------
    // Display
    // -------------------------------------------------------------------------

    async initDisplay() {
        console.log('Initializing display...');
        for (const pkt of INIT_PACKETS) {
            await this._write(pkt);
        }
        console.log('✓ Display initialized');
    }

    async updateDisplay() {
        const tmpArray = [];
        for (let lineIdx = 0; lineIdx < this.page.length; lineIdx++) {
            const line = this.page[lineIdx];
            for (let charIdx = 0; charIdx < PAGE_CHARS_PER_LINE; charIdx++) {
                const colorCode = COLORS[this.colors[lineIdx][charIdx]] || COLORS.W;
                tmpArray.push(colorCode & 0xFF, (colorCode >> 8) & 0xFF, line.charCodeAt(charIdx));
            }
        }
        // Pad to multiple of 63
        const padLength = Math.ceil(tmpArray.length / 63) * 63 - tmpArray.length;
        for (let i = 0; i < padLength; i++) tmpArray.push(0x00);

        for (let i = 0; i < tmpArray.length; i += 63) {
            await this._write([0xf2, ...tmpArray.slice(i, i + 63)]);
            await new Promise(r => setTimeout(r, 40));
        }
    }

    clear() {
        this.page = this._createEmptyPage();
        this.colors = this._createEmptyColorBuffer();
        return this.updateDisplay();
    }

    // -------------------------------------------------------------------------
    // Lines / colors
    // -------------------------------------------------------------------------

    setLine(lineNum, textOrSegments, color = 'W') {
        if (lineNum < 0 || lineNum >= PAGE_LINES) return;
        if (Array.isArray(textOrSegments)) {
            this._setLineSegments(lineNum, textOrSegments);
        } else {
            const padded = (textOrSegments + ' '.repeat(PAGE_CHARS_PER_LINE)).substring(0, PAGE_CHARS_PER_LINE);
            this.page[lineNum] = padded;
            const c = this._normalizeColor(color);
            for (let i = 0; i < PAGE_CHARS_PER_LINE; i++) this.colors[lineNum][i] = c;
        }
    }

    _setLineSegments(lineNum, segments) {
        let text = '';
        let charIdx = 0;
        for (const seg of segments) {
            const t = seg.text || '';
            const c = this._normalizeColor(seg.color || 'W');
            for (let i = 0; i < t.length && charIdx < PAGE_CHARS_PER_LINE; i++) {
                text += t[i];
                this.colors[lineNum][charIdx++] = c;
            }
        }
        while (charIdx < PAGE_CHARS_PER_LINE) {
            text += ' ';
            this.colors[lineNum][charIdx++] = 'W';
        }
        this.page[lineNum] = text;
    }

    _normalizeColor(color) {
        const map = { white: 'W', amber: 'A', cyan: 'B', green: 'G', magenta: 'M', red: 'R', yellow: 'Y', grey: 'E', gray: 'E' };
        const n = color.toString().toLowerCase();
        return map[n] || color.toUpperCase().charAt(0) || 'W';
    }

    // -------------------------------------------------------------------------
    // LEDs
    // -------------------------------------------------------------------------

    setLED(ledId, brightness) {
        if (typeof ledId === 'string') ledId = LEDS[ledId.toUpperCase()] || 0;
        const data = [0x02, 0x32, 0xbb, 0, 0, 3, 0x49, ledId, brightness, 0, 0, 0, 0, 0];
        return this._write(data);
    }

    setAllLEDs(ledsObj) {
        const promises = [];
        if (typeof ledsObj === 'object') {
            for (const [name, value] of Object.entries(ledsObj)) {
                let brightness;
                if (typeof value === 'boolean') brightness = value ? 255 : 0;
                else if (typeof value === 'number') brightness = Math.max(0, Math.min(255, value));
                else brightness = 0;
                const p = this.setLED(name, brightness);
                if (p) promises.push(p);
            }
        } else {
            for (const id of Object.values(LEDS)) {
                const p = this.setLED(id, ledsObj);
                if (p) promises.push(p);
            }
        }
        return Promise.all(promises);
    }

    // -------------------------------------------------------------------------
    // Button reading
    // -------------------------------------------------------------------------

    startButtonReading(callback, pollIntervalMs) {
        this.buttonCallback = callback;
        if (this._platform === 'linux') {
            this._startButtonReadingLinux();
        } else {
            this._startButtonReadingMac(pollIntervalMs || 50);
        }
    }

    _startButtonReadingMac(pollIntervalMs) {
        // readTimeout(0): returns immediately, does NOT set O_NONBLOCK on the fd
        // (avoids EAGAIN during updateDisplay bursts — see memory notes)
        this._buttonPollInterval = setInterval(() => {
            try {
                const data = this._hidDevice.readTimeout(0);
                if (data && data.length >= 13 && data[0] === 0x01) {
                    this._processButtonData(data);
                }
            } catch (e) { /* device disconnect — swallow */ }
        }, pollIntervalMs);
    }

    _startButtonReadingLinux() {
        this._inEndpoint.on('data', (data) => {
            if (data && data.length >= 13 && data[0] === 0x01) {
                this._processButtonData(data);
            }
        });
        this._inEndpoint.on('error', (err) => {
            console.error('Button read error:', err.message);
        });
        this._inEndpoint.startPoll(2, 64);
    }

    _processButtonData(data) {
        const buttonBytes = data.slice(1, 13);
        const pressed = [];
        for (let byteIdx = 0; byteIdx < 12; byteIdx++) {
            for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
                if (buttonBytes[byteIdx] & (1 << bitIdx)) {
                    pressed.push(byteIdx * 8 + bitIdx);
                }
            }
        }
        if (pressed.length > 0 && this.buttonCallback) {
            this.buttonCallback(pressed);
        }
    }

    stopButtonReading() {
        if (this._buttonPollInterval) {
            clearInterval(this._buttonPollInterval);
            this._buttonPollInterval = null;
        }
        if (this._inEndpoint) {
            try { this._inEndpoint.stopPoll(); } catch (e) { /* ignore */ }
        }
        this.buttonCallback = null;
    }

    // -------------------------------------------------------------------------
    // Close
    // -------------------------------------------------------------------------

    close() {
        this.stopButtonReading();
        if (this._hidDevice) {
            this._hidDevice.close();
            this._hidDevice = null;
        }
        if (this._usbIface) {
            try {
                this._usbIface.release(true, () => {
                    try { this._usbIface.attachKernelDriver(); } catch (e) { /* ignore */ }
                    if (this._usbDevice) { this._usbDevice.close(); this._usbDevice = null; }
                });
            } catch (e) {
                if (this._usbDevice) { this._usbDevice.close(); this._usbDevice = null; }
            }
            this._usbIface = null;
        }
        console.log('Device closed');
    }
}

module.exports = { MCDU, COLORS, LEDS };
